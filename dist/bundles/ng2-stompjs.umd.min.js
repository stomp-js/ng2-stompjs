!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports,require("@angular/core"),require("rxjs/BehaviorSubject"),require("rxjs/Observable"),require("rxjs/Subject"),require("rxjs/add/operator/filter"),require("rxjs/add/operator/first"),require("rxjs/add/operator/share"),require("@stomp/stompjs/index")):"function"==typeof define&&define.amd?define(["exports","@angular/core","rxjs/BehaviorSubject","rxjs/Observable","rxjs/Subject","rxjs/add/operator/filter","rxjs/add/operator/first","rxjs/add/operator/share","@stomp/stompjs/index"],t):t(e["ng2-stompjs"]={},e.ng.core,e.Rx,e.Rx,e.Rx,e.Rx.Observable.prototype,e.Rx.Observable.prototype,e.Rx.Observable.prototype,e[""]["/node_modules/@stomp/stompjs/index"].js)}(this,function(e,t,n,r,i,s,o,c,u){"use strict";var a=this&&this.__extends||function(){var e=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,t){e.__proto__=t}||function(e,t){for(var n in t)t.hasOwnProperty(n)&&(e[n]=t[n])};return function(t,n){function r(){this.constructor=t}e(t,n),t.prototype=null===n?Object.create(n):(r.prototype=n.prototype,new r)}}(),b={};b.CLOSED=0,b.TRYING=1,b.CONNECTED=2,b.DISCONNECTING=3,b[b.CLOSED]="CLOSED",b[b.TRYING]="TRYING",b[b.CONNECTED]="CONNECTED",b[b.DISCONNECTING]="DISCONNECTING";var h=function(){function e(){var e=this;this.queuedMessages=[],this.debug=function(e){console.log(new Date,e)},this.on_connect=function(t){e.debug("Connected"),e._serverHeadersBehaviourSubject.next(t.headers),e.state.next(b.CONNECTED)},this.on_error=function(t){e.errorSubject.next(t),"object"==typeof t&&(t=t.body),e.debug("Error: "+t),e.client.connected||e.state.next(b.CLOSED)},this.state=new n.BehaviorSubject(b.CLOSED),this.connectObservable=this.state.filter(function(e){return e===b.CONNECTED}),this.connectObservable.subscribe(function(){e.sendQueuedMessages()}),this._serverHeadersBehaviourSubject=new n.BehaviorSubject(null),this.serverHeadersObservable=this._serverHeadersBehaviourSubject.filter(function(e){return null!==e}),this.errorSubject=new i.Subject}return Object.defineProperty(e.prototype,"config",{set:function(e){this._config=e},enumerable:!0,configurable:!0}),e.prototype.initStompClient=function(){this.disconnect(),"string"==typeof this._config.url?this.client=u.client(this._config.url):this.client=u.over(this._config.url),this.client.heartbeat.incoming=this._config.heartbeat_in,this.client.heartbeat.outgoing=this._config.heartbeat_out,this.client.reconnect_delay=this._config.reconnect_delay,this._config.debug||(this.debug=function(){}),this.client.debug=this.debug,this.setupOnReceive(),this.setupReceipts()},e.prototype.initAndConnect=function(){this.initStompClient(),this._config.headers||(this._config.headers={}),this.client.connect(this._config.headers,this.on_connect,this.on_error),this.debug("Connecting..."),this.state.next(b.TRYING)},e.prototype.disconnect=function(){var e=this;if(this.client){if(!this.client.connected)return void this.state.next(b.CLOSED);this.state.next(b.DISCONNECTING),this.client.disconnect(function(){return e.state.next(b.CLOSED)})}},e.prototype.connected=function(){return this.state.getValue()===b.CONNECTED},e.prototype.publish=function(e,t,n){void 0===n&&(n={}),this.connected()?this.client.send(e,n,t):(this.debug("Not connected, queueing "+t),this.queuedMessages.push({queueName:e,message:t,headers:n}))},e.prototype.sendQueuedMessages=function(){var e=this.queuedMessages;this.queuedMessages=[],this.debug("Will try sending queued messages "+e);for(var t=0,n=e;t<n.length;t++){var r=n[t];this.debug("Attempting to send "+r),this.publish(r.queueName,r.message,r.headers)}},e.prototype.subscribe=function(e,t){var n=this;void 0===t&&(t={}),this.debug("Request to subscribe "+e),t.ack||(t.ack="auto");return r.Observable.create(function(r){var i,s;return s=n.connectObservable.subscribe(function(){n.debug("Will subscribe to "+e),i=n.client.subscribe(e,function(e){r.next(e)},t)}),function(){n.debug("Stop watching connection state (for "+e+")"),s.unsubscribe(),n.state.getValue()===b.CONNECTED?(n.debug("Will unsubscribe from "+e+" at Stomp"),i.unsubscribe()):n.debug("Stomp not connected, no need to unsubscribe from "+e+" at Stomp")}}).share()},e.prototype.setupOnReceive=function(){var e=this;this.defaultMessagesObservable=new i.Subject,this.client.onreceive=function(t){e.defaultMessagesObservable.next(t)}},e.prototype.setupReceipts=function(){var e=this;this.receiptsObservable=new i.Subject,this.client.onreceipt=function(t){e.receiptsObservable.next(t)}},e.prototype.waitForReceipt=function(e,t){this.receiptsObservable.filter(function(t){return t.headers["receipt-id"]===e}).first().subscribe(function(e){t(e)})},e}();h.decorators=[{type:t.Injectable}],h.ctorParameters=function(){return[]};var d=function(){return function(){}}();d.decorators=[{type:t.Injectable}],d.ctorParameters=function(){return[]};var p=function(e){function t(t){var n=e.call(this)||this;return n.config=t,n.initAndConnect(),n}return a(t,e),t}(h);p.decorators=[{type:t.Injectable}],p.ctorParameters=function(){return[{type:d}]},e.StompRService=h,e.StompService=p,e.StompState=b,e.StompConfig=d,Object.defineProperty(e,"__esModule",{value:!0})});
//# sourceMappingURL=ng2-stompjs.umd.min.js.map
